{"ast":null,"code":"// Working Google Maps Service - No external dependencies\n// This version loads Google Maps API directly via script tag\n\n// Types\n\nclass GoogleMapsService {\n  constructor() {\n    this.google = null;\n    this.isInitialized = false;\n    this.initPromise = null;\n  } // Initialize when first needed\n  async ensureInitialized() {\n    if (this.isInitialized) return;\n    if (this.initPromise) {\n      return this.initPromise;\n    }\n    this.initPromise = this.initialize();\n    return this.initPromise;\n  }\n  async initialize() {\n    try {\n      console.log('üöÄ Initializing Google Maps API...');\n\n      // Check if Google Maps is already loaded\n      if (window.google && window.google.maps) {\n        this.google = window.google;\n        this.isInitialized = true;\n        console.log('‚úÖ Google Maps API already loaded');\n        return;\n      }\n\n      // Load Google Maps API dynamically\n      const apiKey = process.env.REACT_APP_GOOGLE_MAPS_API_KEY;\n      console.log('üîë Environment variables check:');\n      console.log('- REACT_APP_GOOGLE_MAPS_API_KEY:', apiKey ? '‚úÖ Found' : '‚ùå Missing');\n      console.log('- All REACT_APP_ env vars:', Object.keys(process.env).filter(key => key.startsWith('REACT_APP_')));\n      if (!apiKey) {\n        throw new Error('Google Maps API key not found. Please set REACT_APP_GOOGLE_MAPS_API_KEY in your .env file');\n      }\n      console.log('üì° Loading Google Maps script...');\n\n      // Create script tag to load Google Maps\n      const script = document.createElement('script');\n      script.src = `https://maps.googleapis.com/maps/api/js?key=${apiKey}&libraries=places,geometry&callback=initGoogleMaps`;\n      script.async = true;\n      script.defer = true;\n\n      // Set up callback\n      window.initGoogleMaps = () => {\n        console.log('üéØ Google Maps callback triggered');\n        this.google = window.google;\n        this.isInitialized = true;\n        console.log('‚úÖ Google Maps API loaded successfully');\n      };\n\n      // Add script to document\n      document.head.appendChild(script);\n      console.log('üìÑ Script added to document head');\n\n      // Wait for script to load\n      await new Promise((resolve, reject) => {\n        script.onload = () => {\n          console.log('üì• Script loaded, waiting for callback...');\n          // Wait a bit more for the callback\n          setTimeout(() => {\n            if (this.isInitialized) {\n              console.log('üéâ Initialization complete');\n              resolve();\n            } else {\n              console.error('‚ùå Google Maps failed to initialize - callback not triggered');\n              reject(new Error('Google Maps failed to initialize'));\n            }\n          }, 3000); // Increased timeout\n        };\n        script.onerror = () => {\n          console.error('‚ùå Failed to load Google Maps script');\n          reject(new Error('Failed to load Google Maps script'));\n        };\n      });\n    } catch (error) {\n      console.error('‚ùå Failed to initialize Google Maps API:', error);\n      throw error;\n    }\n  }\n\n  // Get place predictions for autocomplete\n  async getPlacePredictions(input) {\n    console.log('üîç Getting place predictions for:', input);\n    await this.ensureInitialized();\n    console.log('‚úÖ Google Maps initialized, creating autocomplete service...');\n    return new Promise((resolve, reject) => {\n      const service = new this.google.maps.places.AutocompleteService();\n      console.log('üîß Autocomplete service created, making request...');\n      service.getPlacePredictions({\n        input,\n        types: ['geocode', 'establishment']\n      }, (predictions, status) => {\n        console.log('üì® Autocomplete response:', {\n          status,\n          predictionsCount: predictions === null || predictions === void 0 ? void 0 : predictions.length\n        });\n        if (status === this.google.maps.places.PlacesServiceStatus.OK && predictions) {\n          const results = predictions.map(prediction => ({\n            placeId: prediction.place_id,\n            description: prediction.description\n          }));\n          console.log('‚úÖ Returning predictions:', results);\n          resolve(results);\n        } else {\n          console.error('‚ùå Autocomplete failed with status:', status);\n          reject(new Error(`Autocomplete failed: ${status}`));\n        }\n      });\n    });\n  }\n\n  // Get location details from place ID\n  async getPlaceDetails(placeId) {\n    await this.ensureInitialized();\n    return new Promise((resolve, reject) => {\n      const service = new this.google.maps.places.PlacesService(new this.google.maps.Map(document.createElement('div')));\n      service.getDetails({\n        placeId,\n        fields: ['geometry', 'formatted_address']\n      }, (place, status) => {\n        var _place$geometry;\n        if (status === this.google.maps.places.PlacesServiceStatus.OK && place !== null && place !== void 0 && (_place$geometry = place.geometry) !== null && _place$geometry !== void 0 && _place$geometry.location) {\n          const location = {\n            lat: place.geometry.location.lat(),\n            lng: place.geometry.location.lng(),\n            address: place.formatted_address\n          };\n          resolve(location);\n        } else {\n          reject(new Error(`Place details failed: ${status}`));\n        }\n      });\n    });\n  }\n\n  // Get route between two points\n  async getRoute(start, end, waypoints = []) {\n    await this.ensureInitialized();\n    return new Promise((resolve, reject) => {\n      const service = new this.google.maps.DirectionsService();\n      const waypointsFormatted = waypoints.map(wp => ({\n        location: new this.google.maps.LatLng(wp.lat, wp.lng),\n        stopover: true\n      }));\n      service.route({\n        origin: new this.google.maps.LatLng(start.lat, start.lng),\n        destination: new this.google.maps.LatLng(end.lat, end.lng),\n        waypoints: waypointsFormatted,\n        optimizeWaypoints: true,\n        travelMode: this.google.maps.TravelMode.DRIVING\n      }, (result, status) => {\n        if (status === this.google.maps.DirectionsStatus.OK && result) {\n          const route = result.routes[0];\n          const leg = route.legs[0];\n          const routeData = {\n            start,\n            end,\n            waypoints,\n            distance: leg.distance.value / 1000,\n            // Convert to km\n            duration: leg.duration.value / 60,\n            // Convert to minutes\n            polyline: route.overview_polyline,\n            bounds: route.bounds\n          };\n          resolve(routeData);\n        } else {\n          reject(new Error(`Directions failed: ${status}`));\n        }\n      });\n    });\n  }\n\n  // Search for places along a route\n  async searchPlacesAlongRoute(route, types, maxDistance = 5) {\n    await this.ensureInitialized();\n    const places = [];\n    const routePoints = this.decodePolyline(route.polyline);\n\n    // Sample points along the route for place search\n    const searchPoints = this.sampleRoutePoints(routePoints, maxDistance);\n    for (const point of searchPoints) {\n      try {\n        const nearbyPlaces = await this.searchNearbyPlaces(point, types, maxDistance * 1000);\n        places.push(...nearbyPlaces);\n      } catch (error) {\n        console.warn(`Failed to search places at point ${point.lat}, ${point.lng}:`, error);\n      }\n    }\n\n    // Remove duplicates and sort by distance\n    const uniquePlaces = this.removeDuplicatePlaces(places);\n    return uniquePlaces.sort((a, b) => a.distance - b.distance);\n  }\n\n  // Search for places near a specific location\n  async searchNearbyPlaces(location, types, radius) {\n    return new Promise((resolve, reject) => {\n      const service = new this.google.maps.places.PlacesService(new this.google.maps.Map(document.createElement('div')));\n      const places = [];\n      let completedSearches = 0;\n      types.forEach(type => {\n        service.nearbySearch({\n          location: new this.google.maps.LatLng(location.lat, location.lng),\n          radius,\n          type: type\n        }, (results, status) => {\n          completedSearches++;\n          if (status === this.google.maps.places.PlacesServiceStatus.OK && results) {\n            results.forEach(place => {\n              var _place$geometry2;\n              if ((_place$geometry2 = place.geometry) !== null && _place$geometry2 !== void 0 && _place$geometry2.location) {\n                var _place$opening_hours;\n                const distance = this.calculateDistance(location.lat, location.lng, place.geometry.location.lat(), place.geometry.location.lng());\n                places.push({\n                  id: place.place_id,\n                  placeId: place.place_id,\n                  name: place.name || '',\n                  type: type,\n                  rating: place.rating,\n                  distance,\n                  location: {\n                    lat: place.geometry.location.lat(),\n                    lng: place.geometry.location.lng()\n                  },\n                  price: place.price_level ? '$'.repeat(place.price_level) : undefined,\n                  openingHours: (_place$opening_hours = place.opening_hours) !== null && _place$opening_hours !== void 0 && _place$opening_hours.open_now ? 'Open Now' : 'Closed',\n                  tags: place.types || []\n                });\n              }\n            });\n          }\n          if (completedSearches === types.length) {\n            resolve(places);\n          }\n        });\n      });\n    });\n  }\n\n  // Decode Google Maps polyline\n  decodePolyline(encoded) {\n    const poly = [];\n    let index = 0,\n      len = encoded.length;\n    let lat = 0,\n      lng = 0;\n    while (index < len) {\n      let shift = 0,\n        result = 0;\n      do {\n        let b = encoded.charCodeAt(index++) - 63;\n        result |= (b & 0x1f) << shift;\n        shift += 5;\n      } while (result >= 0x20);\n      let dlat = result & 1 ? ~(result >> 1) : result >> 1;\n      lat += dlat;\n      shift = 0;\n      result = 0;\n      do {\n        let b = encoded.charCodeAt(index++) - 63;\n        result |= (b & 0x1f) << shift;\n        shift += 5;\n      } while (result >= 0x20);\n      let dlng = result & 1 ? ~(result >> 1) : result >> 1;\n      lng += dlng;\n      poly.push({\n        lat: lat / 1e5,\n        lng: lng / 1e5\n      });\n    }\n    return poly;\n  }\n\n  // Sample points along a route\n  sampleRoutePoints(points, maxDistance) {\n    const sampled = [];\n    for (let i = 0; i < points.length; i += Math.max(1, Math.floor(points.length / 10))) {\n      sampled.push(points[i]);\n    }\n    return sampled;\n  }\n\n  // Calculate distance between two points\n  calculateDistance(lat1, lng1, lat2, lng2) {\n    const R = 6371; // Earth's radius in km\n    const dLat = this.deg2rad(lat2 - lat1);\n    const dLng = this.deg2rad(lng2 - lng1);\n    const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(this.deg2rad(lat1)) * Math.cos(this.deg2rad(lat2)) * Math.sin(dLng / 2) * Math.sin(dLng / 2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n    return R * c;\n  }\n  deg2rad(deg) {\n    return deg * (Math.PI / 180);\n  }\n\n  // Remove duplicate places based on place ID\n  removeDuplicatePlaces(places) {\n    const seen = new Set();\n    return places.filter(place => {\n      if (seen.has(place.placeId)) {\n        return false;\n      }\n      seen.add(place.placeId);\n      return true;\n    });\n  }\n\n  // Geocode an address\n  async geocodeAddress(address) {\n    await this.ensureInitialized();\n    return new Promise((resolve, reject) => {\n      const geocoder = new this.google.maps.Geocoder();\n      geocoder.geocode({\n        address\n      }, (results, status) => {\n        if (status === this.google.maps.GeocoderStatus.OK && results && results[0]) {\n          const location = results[0].geometry.location;\n          resolve({\n            lat: location.lat(),\n            lng: location.lng(),\n            address: results[0].formatted_address\n          });\n        } else {\n          reject(new Error(`Geocoding failed: ${status}`));\n        }\n      });\n    });\n  }\n}\n\n// Create singleton instance\nconst googleMapsService = new GoogleMapsService();\nexport default googleMapsService;","map":{"version":3,"names":["GoogleMapsService","constructor","google","isInitialized","initPromise","ensureInitialized","initialize","console","log","window","maps","apiKey","process","env","REACT_APP_GOOGLE_MAPS_API_KEY","Object","keys","filter","key","startsWith","Error","script","document","createElement","src","async","defer","initGoogleMaps","head","appendChild","Promise","resolve","reject","onload","setTimeout","error","onerror","getPlacePredictions","input","service","places","AutocompleteService","types","predictions","status","predictionsCount","length","PlacesServiceStatus","OK","results","map","prediction","placeId","place_id","description","getPlaceDetails","PlacesService","Map","getDetails","fields","place","_place$geometry","geometry","location","lat","lng","address","formatted_address","getRoute","start","end","waypoints","DirectionsService","waypointsFormatted","wp","LatLng","stopover","route","origin","destination","optimizeWaypoints","travelMode","TravelMode","DRIVING","result","DirectionsStatus","routes","leg","legs","routeData","distance","value","duration","polyline","overview_polyline","bounds","searchPlacesAlongRoute","maxDistance","routePoints","decodePolyline","searchPoints","sampleRoutePoints","point","nearbyPlaces","searchNearbyPlaces","push","warn","uniquePlaces","removeDuplicatePlaces","sort","a","b","radius","completedSearches","forEach","type","nearbySearch","_place$geometry2","_place$opening_hours","calculateDistance","id","name","rating","price","price_level","repeat","undefined","openingHours","opening_hours","open_now","tags","encoded","poly","index","len","shift","charCodeAt","dlat","dlng","points","sampled","i","Math","max","floor","lat1","lng1","lat2","lng2","R","dLat","deg2rad","dLng","sin","cos","c","atan2","sqrt","deg","PI","seen","Set","has","add","geocodeAddress","geocoder","Geocoder","geocode","GeocoderStatus","googleMapsService"],"sources":["D:/NavPlaces/src/services/GoogleMapsService.ts"],"sourcesContent":["// Working Google Maps Service - No external dependencies\r\n// This version loads Google Maps API directly via script tag\r\n\r\n// Types\r\nexport interface Location {\r\n  lat: number;\r\n  lng: number;\r\n  address?: string;\r\n}\r\n\r\nexport interface Route {\r\n  start: Location;\r\n  end: Location;\r\n  waypoints: Location[];\r\n  distance: number;\r\n  duration: number;\r\n  polyline: string;\r\n  bounds: any;\r\n}\r\n\r\nexport interface PlaceOfInterest {\r\n  id: string;\r\n  name: string;\r\n  type: string;\r\n  description?: string;\r\n  rating?: number;\r\n  distance: number;\r\n  location: Location;\r\n  photos?: string[];\r\n  price?: string;\r\n  openingHours?: string;\r\n  tags?: string[];\r\n  placeId: string;\r\n}\r\n\r\nexport interface AutocompleteResult {\r\n  placeId: string;\r\n  description: string;\r\n  location?: Location;\r\n}\r\n\r\nclass GoogleMapsService {\r\n  private google: any = null;\r\n  private isInitialized = false;\r\n  private initPromise: Promise<void> | null = null;\r\n\r\n  constructor() {\r\n    // Initialize when first needed\r\n  }\r\n\r\n  private async ensureInitialized(): Promise<void> {\r\n    if (this.isInitialized) return;\r\n    \r\n    if (this.initPromise) {\r\n      return this.initPromise;\r\n    }\r\n\r\n    this.initPromise = this.initialize();\r\n    return this.initPromise;\r\n  }\r\n\r\n  private async initialize(): Promise<void> {\r\n    try {\r\n      console.log('üöÄ Initializing Google Maps API...');\r\n      \r\n      // Check if Google Maps is already loaded\r\n      if (window.google && window.google.maps) {\r\n        this.google = window.google;\r\n        this.isInitialized = true;\r\n        console.log('‚úÖ Google Maps API already loaded');\r\n        return;\r\n      }\r\n\r\n      // Load Google Maps API dynamically\r\n      const apiKey = process.env.REACT_APP_GOOGLE_MAPS_API_KEY;\r\n      console.log('üîë Environment variables check:');\r\n      console.log('- REACT_APP_GOOGLE_MAPS_API_KEY:', apiKey ? '‚úÖ Found' : '‚ùå Missing');\r\n      console.log('- All REACT_APP_ env vars:', Object.keys(process.env).filter(key => key.startsWith('REACT_APP_')));\r\n      \r\n      if (!apiKey) {\r\n        throw new Error('Google Maps API key not found. Please set REACT_APP_GOOGLE_MAPS_API_KEY in your .env file');\r\n      }\r\n\r\n      console.log('üì° Loading Google Maps script...');\r\n      \r\n      // Create script tag to load Google Maps\r\n      const script = document.createElement('script');\r\n      script.src = `https://maps.googleapis.com/maps/api/js?key=${apiKey}&libraries=places,geometry&callback=initGoogleMaps`;\r\n      script.async = true;\r\n      script.defer = true;\r\n\r\n      // Set up callback\r\n      (window as any).initGoogleMaps = () => {\r\n        console.log('üéØ Google Maps callback triggered');\r\n        this.google = window.google;\r\n        this.isInitialized = true;\r\n        console.log('‚úÖ Google Maps API loaded successfully');\r\n      };\r\n\r\n      // Add script to document\r\n      document.head.appendChild(script);\r\n      console.log('üìÑ Script added to document head');\r\n\r\n      // Wait for script to load\r\n      await new Promise<void>((resolve, reject) => {\r\n        script.onload = () => {\r\n          console.log('üì• Script loaded, waiting for callback...');\r\n          // Wait a bit more for the callback\r\n          setTimeout(() => {\r\n            if (this.isInitialized) {\r\n              console.log('üéâ Initialization complete');\r\n              resolve();\r\n            } else {\r\n              console.error('‚ùå Google Maps failed to initialize - callback not triggered');\r\n              reject(new Error('Google Maps failed to initialize'));\r\n            }\r\n          }, 3000); // Increased timeout\r\n        };\r\n        script.onerror = () => {\r\n          console.error('‚ùå Failed to load Google Maps script');\r\n          reject(new Error('Failed to load Google Maps script'));\r\n        };\r\n      });\r\n\r\n    } catch (error) {\r\n      console.error('‚ùå Failed to initialize Google Maps API:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Get place predictions for autocomplete\r\n  async getPlacePredictions(input: string): Promise<AutocompleteResult[]> {\r\n    console.log('üîç Getting place predictions for:', input);\r\n    await this.ensureInitialized();\r\n    console.log('‚úÖ Google Maps initialized, creating autocomplete service...');\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const service = new this.google.maps.places.AutocompleteService();\r\n      console.log('üîß Autocomplete service created, making request...');\r\n      \r\n      service.getPlacePredictions(\r\n        {\r\n          input,\r\n          types: ['geocode', 'establishment'],\r\n        },\r\n        (predictions: any[], status: any) => {\r\n          console.log('üì® Autocomplete response:', { status, predictionsCount: predictions?.length });\r\n          if (status === this.google.maps.places.PlacesServiceStatus.OK && predictions) {\r\n            const results: AutocompleteResult[] = predictions.map((prediction: any) => ({\r\n              placeId: prediction.place_id,\r\n              description: prediction.description,\r\n            }));\r\n            console.log('‚úÖ Returning predictions:', results);\r\n            resolve(results);\r\n          } else {\r\n            console.error('‚ùå Autocomplete failed with status:', status);\r\n            reject(new Error(`Autocomplete failed: ${status}`));\r\n          }\r\n        }\r\n      );\r\n    });\r\n  }\r\n\r\n  // Get location details from place ID\r\n  async getPlaceDetails(placeId: string): Promise<Location> {\r\n    await this.ensureInitialized();\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const service = new this.google.maps.places.PlacesService(\r\n        new this.google.maps.Map(document.createElement('div'))\r\n      );\r\n\r\n      service.getDetails(\r\n        {\r\n          placeId,\r\n          fields: ['geometry', 'formatted_address'],\r\n        },\r\n        (place: any, status: any) => {\r\n          if (status === this.google.maps.places.PlacesServiceStatus.OK && place?.geometry?.location) {\r\n            const location: Location = {\r\n              lat: place.geometry.location.lat(),\r\n              lng: place.geometry.location.lng(),\r\n              address: place.formatted_address,\r\n            };\r\n            resolve(location);\r\n          } else {\r\n            reject(new Error(`Place details failed: ${status}`));\r\n          }\r\n        }\r\n      );\r\n    });\r\n  }\r\n\r\n  // Get route between two points\r\n  async getRoute(start: Location, end: Location, waypoints: Location[] = []): Promise<Route> {\r\n    await this.ensureInitialized();\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const service = new this.google.maps.DirectionsService();\r\n\r\n      const waypointsFormatted = waypoints.map(wp => ({\r\n        location: new this.google.maps.LatLng(wp.lat, wp.lng),\r\n        stopover: true,\r\n      }));\r\n\r\n      service.route(\r\n        {\r\n          origin: new this.google.maps.LatLng(start.lat, start.lng),\r\n          destination: new this.google.maps.LatLng(end.lat, end.lng),\r\n          waypoints: waypointsFormatted,\r\n          optimizeWaypoints: true,\r\n          travelMode: this.google.maps.TravelMode.DRIVING,\r\n        },\r\n        (result: any, status: any) => {\r\n          if (status === this.google.maps.DirectionsStatus.OK && result) {\r\n            const route = result.routes[0];\r\n            const leg = route.legs[0];\r\n            \r\n            const routeData: Route = {\r\n              start,\r\n              end,\r\n              waypoints,\r\n              distance: leg.distance.value / 1000, // Convert to km\r\n              duration: leg.duration.value / 60, // Convert to minutes\r\n              polyline: route.overview_polyline,\r\n              bounds: route.bounds,\r\n            };\r\n            resolve(routeData);\r\n          } else {\r\n            reject(new Error(`Directions failed: ${status}`));\r\n          }\r\n        }\r\n      );\r\n    });\r\n  }\r\n\r\n  // Search for places along a route\r\n  async searchPlacesAlongRoute(\r\n    route: Route,\r\n    types: string[],\r\n    maxDistance: number = 5\r\n  ): Promise<PlaceOfInterest[]> {\r\n    await this.ensureInitialized();\r\n\r\n    const places: PlaceOfInterest[] = [];\r\n    const routePoints = this.decodePolyline(route.polyline);\r\n    \r\n    // Sample points along the route for place search\r\n    const searchPoints = this.sampleRoutePoints(routePoints, maxDistance);\r\n\r\n    for (const point of searchPoints) {\r\n      try {\r\n        const nearbyPlaces = await this.searchNearbyPlaces(point, types, maxDistance * 1000);\r\n        places.push(...nearbyPlaces);\r\n      } catch (error) {\r\n        console.warn(`Failed to search places at point ${point.lat}, ${point.lng}:`, error);\r\n      }\r\n    }\r\n\r\n    // Remove duplicates and sort by distance\r\n    const uniquePlaces = this.removeDuplicatePlaces(places);\r\n    return uniquePlaces.sort((a, b) => a.distance - b.distance);\r\n  }\r\n\r\n  // Search for places near a specific location\r\n  private async searchNearbyPlaces(\r\n    location: Location,\r\n    types: string[],\r\n    radius: number\r\n  ): Promise<PlaceOfInterest[]> {\r\n    return new Promise((resolve, reject) => {\r\n      const service = new this.google.maps.places.PlacesService(\r\n        new this.google.maps.Map(document.createElement('div'))\r\n      );\r\n\r\n      const places: PlaceOfInterest[] = [];\r\n      let completedSearches = 0;\r\n\r\n      types.forEach(type => {\r\n        service.nearbySearch(\r\n          {\r\n            location: new this.google.maps.LatLng(location.lat, location.lng),\r\n            radius,\r\n            type: type as any,\r\n          },\r\n          (results: any[], status: any) => {\r\n            completedSearches++;\r\n            \r\n            if (status === this.google.maps.places.PlacesServiceStatus.OK && results) {\r\n              results.forEach((place: any) => {\r\n                if (place.geometry?.location) {\r\n                  const distance = this.calculateDistance(\r\n                    location.lat,\r\n                    location.lng,\r\n                    place.geometry.location.lat(),\r\n                    place.geometry.location.lng()\r\n                  );\r\n\r\n                  places.push({\r\n                    id: place.place_id,\r\n                    placeId: place.place_id,\r\n                    name: place.name || '',\r\n                    type: type,\r\n                    rating: place.rating,\r\n                    distance,\r\n                    location: {\r\n                      lat: place.geometry.location.lat(),\r\n                      lng: place.geometry.location.lng(),\r\n                    },\r\n                    price: place.price_level ? '$'.repeat(place.price_level) : undefined,\r\n                    openingHours: place.opening_hours?.open_now ? 'Open Now' : 'Closed',\r\n                    tags: place.types || [],\r\n                  });\r\n                }\r\n              });\r\n            }\r\n\r\n            if (completedSearches === types.length) {\r\n              resolve(places);\r\n            }\r\n          }\r\n        );\r\n      });\r\n    });\r\n  }\r\n\r\n  // Decode Google Maps polyline\r\n  private decodePolyline(encoded: string): Location[] {\r\n    const poly: Location[] = [];\r\n    let index = 0, len = encoded.length;\r\n    let lat = 0, lng = 0;\r\n\r\n    while (index < len) {\r\n      let shift = 0, result = 0;\r\n\r\n      do {\r\n        let b = encoded.charCodeAt(index++) - 63;\r\n        result |= (b & 0x1f) << shift;\r\n        shift += 5;\r\n      } while (result >= 0x20);\r\n\r\n      let dlat = ((result & 1) ? ~(result >> 1) : (result >> 1));\r\n      lat += dlat;\r\n\r\n      shift = 0;\r\n      result = 0;\r\n\r\n      do {\r\n        let b = encoded.charCodeAt(index++) - 63;\r\n        result |= (b & 0x1f) << shift;\r\n        shift += 5;\r\n      } while (result >= 0x20);\r\n\r\n      let dlng = ((result & 1) ? ~(result >> 1) : (result >> 1));\r\n      lng += dlng;\r\n\r\n      poly.push({ lat: lat / 1e5, lng: lng / 1e5 });\r\n    }\r\n\r\n    return poly;\r\n  }\r\n\r\n  // Sample points along a route\r\n  private sampleRoutePoints(points: Location[], maxDistance: number): Location[] {\r\n    const sampled: Location[] = [];\r\n\r\n    for (let i = 0; i < points.length; i += Math.max(1, Math.floor(points.length / 10))) {\r\n      sampled.push(points[i]);\r\n    }\r\n\r\n    return sampled;\r\n  }\r\n\r\n  // Calculate distance between two points\r\n  private calculateDistance(lat1: number, lng1: number, lat2: number, lng2: number): number {\r\n    const R = 6371; // Earth's radius in km\r\n    const dLat = this.deg2rad(lat2 - lat1);\r\n    const dLng = this.deg2rad(lng2 - lng1);\r\n    const a =\r\n      Math.sin(dLat / 2) * Math.sin(dLat / 2) +\r\n      Math.cos(this.deg2rad(lat1)) * Math.cos(this.deg2rad(lat2)) *\r\n      Math.sin(dLng / 2) * Math.sin(dLng / 2);\r\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\r\n    return R * c;\r\n  }\r\n\r\n  private deg2rad(deg: number): number {\r\n    return deg * (Math.PI / 180);\r\n  }\r\n\r\n  // Remove duplicate places based on place ID\r\n  private removeDuplicatePlaces(places: PlaceOfInterest[]): PlaceOfInterest[] {\r\n    const seen = new Set<string>();\r\n    return places.filter(place => {\r\n      if (seen.has(place.placeId)) {\r\n        return false;\r\n      }\r\n      seen.add(place.placeId);\r\n      return true;\r\n    });\r\n  }\r\n\r\n  // Geocode an address\r\n  async geocodeAddress(address: string): Promise<Location> {\r\n    await this.ensureInitialized();\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const geocoder = new this.google.maps.Geocoder();\r\n      \r\n      geocoder.geocode({ address }, (results: any[], status: any) => {\r\n        if (status === this.google.maps.GeocoderStatus.OK && results && results[0]) {\r\n          const location = results[0].geometry.location;\r\n          resolve({\r\n            lat: location.lat(),\r\n            lng: location.lng(),\r\n            address: results[0].formatted_address,\r\n          });\r\n        } else {\r\n          reject(new Error(`Geocoding failed: ${status}`));\r\n        }\r\n      });\r\n    });\r\n  }\r\n}\r\n\r\n// Create singleton instance\r\nconst googleMapsService = new GoogleMapsService();\r\nexport default googleMapsService; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}